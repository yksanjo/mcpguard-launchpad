AWSTemplateFormatVersion: '2010-09-09'
Description: 'MCPGuard Launchpad - Deploy MCP Security Scanner as a Service'

Parameters:
  InstanceType:
    Type: String
    Default: t3.micro
    AllowedValues:
      - t3.micro
      - t3.small
      - t3.medium
    Description: EC2 instance type (t3.micro is sufficient)

  AdminEmail:
    Type: String
    Description: Admin email for notifications
    AllowedPattern: ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$

  ApiKey:
    Type: String
    NoEcho: true
    Description: API key for authenticated scans (leave blank to auto-generate)
    Default: ''

  WebhookSecret:
    Type: String
    NoEcho: true
    Description: Secret for webhook verification (leave blank to auto-generate)
    Default: ''

  DomainName:
    Type: String
    Description: Custom domain (optional)
    Default: ''

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Instance Configuration"
        Parameters:
          - InstanceType
      - Label:
          default: "Security"
        Parameters:
          - ApiKey
          - WebhookSecret
      - Label:
          default: "Access"
        Parameters:
          - AdminEmail
          - DomainName

Resources:
  # VPC and Networking
  MCPGuardVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: mcpguard-vpc

  PublicSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref MCPGuardVPC
      CidrBlock: 10.0.1.0/24
      MapPublicIpOnLaunch: true
      AvailabilityZone: !Select [0, !GetAZs '']
      Tags:
        - Key: Name
          Value: mcpguard-public-subnet

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: mcpguard-igw

  AttachGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref MCPGuardVPC
      InternetGatewayId: !Ref InternetGateway

  RouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref MCPGuardVPC
      Tags:
        - Key: Name
          Value: mcpguard-rt

  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: AttachGateway
    Properties:
      RouteTableId: !Ref RouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  SubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnet
      RouteTableId: !Ref RouteTable

  # Security Group
  MCPGuardSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for MCPGuard
      VpcId: !Ref MCPGuardVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
          Description: SSH
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: HTTPS
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
          Description: HTTP
        - IpProtocol: tcp
          FromPort: 3000
          ToPort: 3000
          CidrIp: 0.0.0.0/0
          Description: Web UI
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: mcpguard-sg

  # Secrets
  MCPGuardSecrets:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: mcpguard-secrets
      Description: Secrets for MCPGuard
      SecretString: !Sub |
        {
          "API_KEY": "${ApiKey}",
          "WEBHOOK_SECRET": "${WebhookSecret}",
          "ADMIN_EMAIL": "${AdminEmail}"
        }

  # IAM Role
  MCPGuardInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyName: SecretsManagerAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: !Ref MCPGuardSecrets

  MCPGuardInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref MCPGuardInstanceRole

  # EC2 Instance
  MCPGuardInstance:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: !Ref InstanceType
      ImageId: !FindInMap [RegionMap, !Ref 'AWS::Region', AMI]
      SubnetId: !Ref PublicSubnet
      SecurityGroupIds:
        - !Ref MCPGuardSecurityGroup
      IamInstanceProfile: !Ref MCPGuardInstanceProfile
      BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            VolumeSize: 10
            VolumeType: gp3
            Encrypted: true
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          set -e

          # Update system
          apt-get update && apt-get upgrade -y

          # Install dependencies
          apt-get install -y curl git jq awscli sqlite3

          # Install Node.js 20
          curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
          apt-get install -y nodejs

          # Get secrets
          SECRETS=$(aws secretsmanager get-secret-value --secret-id mcpguard-secrets --region ${AWS::Region} --query SecretString --output text)
          API_KEY=$(echo "$SECRETS" | jq -r '.API_KEY')
          WEBHOOK_SECRET=$(echo "$SECRETS" | jq -r '.WEBHOOK_SECRET')
          ADMIN_EMAIL=$(echo "$SECRETS" | jq -r '.ADMIN_EMAIL')

          # Generate secrets if not provided
          if [ -z "$API_KEY" ] || [ "$API_KEY" = "null" ]; then
            API_KEY=$(openssl rand -hex 24)
          fi
          if [ -z "$WEBHOOK_SECRET" ] || [ "$WEBHOOK_SECRET" = "null" ]; then
            WEBHOOK_SECRET=$(openssl rand -hex 24)
          fi

          # Setup MCPGuard web service
          mkdir -p /opt/mcpguard-service
          cd /opt/mcpguard-service

          # Install mcpguard
          npm install mcpguard

          # Create web service wrapper
          cat > server.js <<'SERVEREOF'
          const express = require('express');
          const cors = require('cors');
          const { execSync } = require('child_process');
          const fs = require('fs');
          const path = require('path');
          const crypto = require('crypto');
          const sqlite3 = require('better-sqlite3');

          const app = express();
          app.use(cors());
          app.use(express.json({ limit: '1mb' }));

          // Initialize SQLite database
          const db = sqlite3('/opt/mcpguard-service/scans.db');
          db.exec(`
            CREATE TABLE IF NOT EXISTS scans (
              id TEXT PRIMARY KEY,
              config TEXT,
              result TEXT,
              risk_level TEXT,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
          `);

          const API_KEY = process.env.API_KEY;
          const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;

          // Auth middleware
          const authenticate = (req, res, next) => {
            const authHeader = req.headers.authorization;
            if (!authHeader || authHeader !== `Bearer ${API_KEY}`) {
              return res.status(401).json({ error: 'Unauthorized' });
            }
            next();
          };

          // Public scan endpoint (rate limited)
          let publicScanCount = {};
          app.post('/api/scan', (req, res) => {
            const ip = req.ip;
            const now = Date.now();

            // Simple rate limiting: 10 scans per hour per IP
            if (!publicScanCount[ip]) publicScanCount[ip] = [];
            publicScanCount[ip] = publicScanCount[ip].filter(t => now - t < 3600000);
            if (publicScanCount[ip].length >= 10) {
              return res.status(429).json({ error: 'Rate limit exceeded. Use API key for unlimited scans.' });
            }
            publicScanCount[ip].push(now);

            try {
              const { config } = req.body;
              if (!config) {
                return res.status(400).json({ error: 'Config required' });
              }

              const scanId = crypto.randomUUID();
              const tempFile = `/tmp/scan-${scanId}.json`;

              // Write config to temp file
              fs.writeFileSync(tempFile, JSON.stringify(config));

              // Run mcpguard
              let result;
              try {
                result = execSync(`npx mcpguard scan ${tempFile} --output json`, {
                  encoding: 'utf-8',
                  timeout: 30000
                });
              } catch (e) {
                result = e.stdout || '{}';
              }

              // Clean up
              fs.unlinkSync(tempFile);

              const parsed = JSON.parse(result || '{}');
              const riskLevel = parsed.summary?.highestRisk || 'unknown';

              // Store in database
              db.prepare('INSERT INTO scans (id, config, result, risk_level) VALUES (?, ?, ?, ?)')
                .run(scanId, JSON.stringify(config), result, riskLevel);

              res.json({
                scan_id: scanId,
                ...parsed
              });
            } catch (error) {
              res.status(500).json({ error: error.message });
            }
          });

          // Authenticated scan (no rate limit)
          app.post('/api/v1/scan', authenticate, (req, res) => {
            try {
              const { config } = req.body;
              if (!config) {
                return res.status(400).json({ error: 'Config required' });
              }

              const scanId = crypto.randomUUID();
              const tempFile = `/tmp/scan-${scanId}.json`;

              fs.writeFileSync(tempFile, JSON.stringify(config));

              let result;
              try {
                result = execSync(`npx mcpguard scan ${tempFile} --output json`, {
                  encoding: 'utf-8',
                  timeout: 30000
                });
              } catch (e) {
                result = e.stdout || '{}';
              }

              fs.unlinkSync(tempFile);

              const parsed = JSON.parse(result || '{}');
              const riskLevel = parsed.summary?.highestRisk || 'unknown';

              db.prepare('INSERT INTO scans (id, config, result, risk_level) VALUES (?, ?, ?, ?)')
                .run(scanId, JSON.stringify(config), result, riskLevel);

              res.json({
                scan_id: scanId,
                ...parsed
              });
            } catch (error) {
              res.status(500).json({ error: error.message });
            }
          });

          // Get scan history
          app.get('/api/scans', authenticate, (req, res) => {
            const scans = db.prepare('SELECT id, risk_level, created_at FROM scans ORDER BY created_at DESC LIMIT 100').all();
            res.json({ scans });
          });

          // Get scan details
          app.get('/api/scans/:id', (req, res) => {
            const scan = db.prepare('SELECT * FROM scans WHERE id = ?').get(req.params.id);
            if (!scan) {
              return res.status(404).json({ error: 'Scan not found' });
            }
            res.json({
              ...scan,
              config: JSON.parse(scan.config),
              result: JSON.parse(scan.result)
            });
          });

          // Webhook for CI/CD
          app.post('/api/webhook/github', (req, res) => {
            const signature = req.headers['x-hub-signature-256'];
            const payload = JSON.stringify(req.body);
            const expected = 'sha256=' + crypto.createHmac('sha256', WEBHOOK_SECRET).update(payload).digest('hex');

            if (signature !== expected) {
              return res.status(401).json({ error: 'Invalid signature' });
            }

            // Handle push events - scan any MCP configs in the repo
            // This is a placeholder - would need GitHub API integration
            res.json({ received: true });
          });

          // Health check
          app.get('/health', (req, res) => {
            res.json({ status: 'ok', version: '1.0.0' });
          });

          // Simple web UI
          app.get('/', (req, res) => {
            res.send(`
              <!DOCTYPE html>
              <html>
              <head>
                <title>MCPGuard Scanner</title>
                <style>
                  body { font-family: system-ui; max-width: 800px; margin: 0 auto; padding: 20px; background: #0d1117; color: #c9d1d9; }
                  h1 { color: #58a6ff; }
                  textarea { width: 100%; height: 300px; background: #161b22; color: #c9d1d9; border: 1px solid #30363d; border-radius: 6px; padding: 10px; font-family: monospace; }
                  button { background: #238636; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 16px; margin-top: 10px; }
                  button:hover { background: #2ea043; }
                  #result { margin-top: 20px; padding: 20px; background: #161b22; border-radius: 6px; white-space: pre-wrap; font-family: monospace; }
                  .high { color: #f85149; }
                  .medium { color: #d29922; }
                  .low { color: #3fb950; }
                </style>
              </head>
              <body>
                <h1>MCPGuard Scanner</h1>
                <p>Paste your MCP configuration JSON below to scan for security vulnerabilities.</p>
                <textarea id="config" placeholder='{"mcpServers": { ... }}'></textarea>
                <button onclick="scan()">Scan Configuration</button>
                <div id="result"></div>
                <script>
                  async function scan() {
                    const config = document.getElementById('config').value;
                    const result = document.getElementById('result');
                    result.innerHTML = 'Scanning...';
                    try {
                      const parsed = JSON.parse(config);
                      const res = await fetch('/api/scan', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ config: parsed })
                      });
                      const data = await res.json();
                      if (data.error) {
                        result.innerHTML = '<span class="high">Error: ' + data.error + '</span>';
                      } else {
                        result.innerHTML = JSON.stringify(data, null, 2);
                      }
                    } catch (e) {
                      result.innerHTML = '<span class="high">Error: ' + e.message + '</span>';
                    }
                  }
                </script>
              </body>
              </html>
            `);
          });

          const PORT = process.env.PORT || 3000;
          app.listen(PORT, () => {
            console.log(`MCPGuard service running on port ${PORT}`);
          });
          SERVEREOF

          # Install additional dependencies
          npm install express cors better-sqlite3

          # Create environment file
          cat > .env <<EOF
          API_KEY=$API_KEY
          WEBHOOK_SECRET=$WEBHOOK_SECRET
          PORT=3000
          EOF

          # Install PM2
          npm install -g pm2

          # Start service
          pm2 start server.js --name mcpguard-service
          pm2 save
          pm2 startup systemd -u root --hp /root

          # Install Caddy
          apt-get install -y debian-keyring debian-archive-keyring apt-transport-https
          curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg
          curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | tee /etc/apt/sources.list.d/caddy-stable.list
          apt-get update
          apt-get install caddy -y

          # Configure Caddy
          cat > /etc/caddy/Caddyfile <<EOF
          :80 {
            reverse_proxy localhost:3000
          }
          EOF

          systemctl restart caddy

          # Save API key to a file for user reference
          echo "Your MCPGuard API Key: $API_KEY" > /opt/mcpguard-service/API_KEY.txt
          chmod 600 /opt/mcpguard-service/API_KEY.txt

          echo "MCPGuard installation complete!"
      Tags:
        - Key: Name
          Value: mcpguard-instance

  # Elastic IP
  MCPGuardEIP:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc
      Tags:
        - Key: Name
          Value: mcpguard-eip

  EIPAssociation:
    Type: AWS::EC2::EIPAssociation
    Properties:
      InstanceId: !Ref MCPGuardInstance
      EIP: !Ref MCPGuardEIP

Mappings:
  RegionMap:
    us-east-1:
      AMI: ami-0c7217cdde317cfec
    us-east-2:
      AMI: ami-05fb0b8c1424f266b
    us-west-1:
      AMI: ami-0ce2cb35386fc22e9
    us-west-2:
      AMI: ami-008fe2fc65df48dac
    eu-west-1:
      AMI: ami-0905a3c97561e0b69
    eu-central-1:
      AMI: ami-0faab6bdbac9486fb
    ap-northeast-1:
      AMI: ami-0d52744d6551d851e
    ap-southeast-1:
      AMI: ami-0df7a207adb9748c7
    ap-southeast-2:
      AMI: ami-0310483fb2b488153

Outputs:
  ScannerURL:
    Description: MCPGuard Web Scanner URL
    Value: !Sub 'http://${MCPGuardEIP}'

  APIURL:
    Description: MCPGuard API URL
    Value: !Sub 'http://${MCPGuardEIP}/api'

  InstancePublicIP:
    Description: Public IP address
    Value: !Ref MCPGuardEIP

  SSHCommand:
    Description: SSH command to connect
    Value: !Sub 'ssh ubuntu@${MCPGuardEIP}'

  GetAPIKey:
    Description: Command to retrieve your API key
    Value: !Sub 'ssh ubuntu@${MCPGuardEIP} "cat /opt/mcpguard-service/API_KEY.txt"'

  NextSteps:
    Description: What to do next
    Value: |
      1. Wait 5 minutes for installation
      2. Visit the Scanner URL
      3. Paste your MCP config and scan
      4. Retrieve API key for CI/CD integration
